
/* c 编程细节 */
int* res = (int*)malloc(sizeof(int) * 2);

int **newArray(int **nums, int row, int col) {
    if (row <= 0 || col <= 0 || nums == NULL)
        return NULL;
    int **ret = (int **)malloc(row*sizeof(int *));
    int r;
    for (r = 0; r < row; r++)
        ret[r] = (int *)malloc(col * sizeof(int));
    int a;
    int i,j,k,t;
    for (i = 0; i < row; i++) {
        for (j = 0; j < col; j++) {
            a = 0;
            for (k = 0; k < col; k++) {
                if ((*((int *)nums+col*i+k) > *((int *)nums+col*i+j)))
                    a++;
            }
            for (t = 0; t < row; t++) {
                if (*((int *)nums+col*t+j) > *((int *)nums+col*i+j))
                    a++;
            }
            ret[i][j] = a;
        }
    }
    return ret;
}

/* cpp 编程细节 */
auto levelOrder = vector<vector<int>>();
#include <algorithm>
reverse(levelOrder.begin(), levelOrder.end());

/* 提问： 给定一个int型数组，找出该数组中出现次数大于数组长度一半的int值。*/

/** 
 * 算法基础：摩尔投票法 
 * @param nums 
 * @return 
 */  
int majorityElement(int[] nums, int len) {  
    int majority = -1;

    int count = 0;
	int i = 0;
  
    for (i=0; i<len; i++) {
        if (count == 0) {
            majority = nums[i];
            count++;
        } else {
            if (majority == nums[i]) {  
                count++;  
            } else {  
                count--;  
            }  
        }  
    }  
  
    int counter = 0;  
    if (count <= 0) {  
        return -1;  
    } else {  
        for (i=0; i<len; i++) {  
            if (nums[i] == majority) counter ++;  
        }  
    }  
  
    if (counter > nums.length / 2) {  
        return majority;  
    }  
  
    return -1;  
}


/*
 * 给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。
 * 进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。
*/

class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        int a = INT_MAX, b = INT_MAX;
        int counta = 0, countb = 0;

        for(auto num: nums){
            if(num == a){
                counta++;
            }
            else if (num == b){
                countb++;
            }
            else if(counta == 0){
                a = num;
                counta++;
            }
            else if(countb == 0){
                b = num;
                countb++;
            }
            else{
                counta--;
                countb--;
            }
        }

        vector<int> res;
        counta = countb = 0;
        for(auto num: nums){
            if(num == a) counta++;
            else if(num == b) countb++;
        }
        if(counta > nums.size()/3) res.push_back(a);
        if(countb > nums.size()/3) res.push_back(b);
        return res;
    }
};

/* 翻转链表 */
struct ListNode* reverseList(struct ListNode* head){
    struct ListNode *nextNode, *preNode = NULL;
    while (head) {
        nextNode = head->next;
        head->next = preNode;
        preNode = head;
        head = nextNode;
    }
    return preNode;
}


/*
给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
*/
class Solution {
    long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        // 访问左子树
        if (!isValidBST(root.left)) {
            return false;
        }
        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。
        if (root.val <= pre) {
            return false;
        }
        pre = root.val;
        // 访问右子树
        return isValidBST(root.right);
    }
}

/*
给你一个整数数组 arr 。请你返回和为 奇数 的子数组数目。

由于答案可能会很大，请你将结果对 10^9 + 7 取余后返回。

方法一：前缀和 + 数学
这道题要求返回和为奇数的子数组数目。为了快速计算任意子数组的和，可以通过维护前缀和的方式。这道题只需要知道每个子数组的和的奇偶性，不需要知道子数组的和的具体值，因此不需要维护每一个前缀和，只需要维护奇数前缀和的数量与偶数前缀和的数量。

分别使用 odd 和 even 表示奇数前缀和的数量与偶数前缀和的数量。初始时，odd=0，even=1，因为空的前缀的和是 0，也是偶数前缀和。

遍历数组 arr 并计算前缀和。对于下标 i 的位置的前缀和（即 \textit{arr}[0]+\textit{arr}[1]+\ldots+\textit{arr}[i]arr[0]+arr[1]+…+arr[i]），根据奇偶性进行如下操作：

当下标 ii 的位置的前缀和是偶数时，如果下标 jj 满足 j < ij<i 且下标 jj 的位置的前缀和是奇数，则从下标 j+1j+1 到下标 ii 的子数组的和是奇数，因此，以下标 ii 结尾的子数组中，和为奇数的子数组的数量即为奇数前缀和的数量 \textit{odd}odd；

当下标 ii 的位置的前缀和是奇数时，如果下标 jj 满足 j < ij<i 且下标 jj 的位置的前缀和是偶数，则从下标 j+1j+1 到下标 ii 的子数组的和是奇数，因此，以下标 ii 结尾的子数组中，和为奇数的子数组的数量即为偶数前缀和的数量 \textit{even}even。

上述下标 jj 的最小可能取值为 -1−1，当 j=-1j=−1 时表示下标 jj 的位置的前缀为空。

在更新和为奇数的子数组数量之后，需要根据下标 ii 的位置的前缀和的奇偶性更新 \textit{odd}odd 或 \textit{even}even 的值。如果前缀和是奇数，则 \textit{odd}odd 的值加 11；如果前缀和是偶数，则 \textit{even}even 的值加 11。

*/

class Solution {
public:
    int numOfSubarrays(vector<int>& arr) {
        const int MODULO = 1000000007;
        int odd = 0, even = 1;
        int subarrays = 0;
        int sum = 0;
        int length = arr.size();
        for (int i = 0; i < length; i++) {
            sum += arr[i];
            subarrays = (subarrays + (sum % 2 == 0 ? odd : even)) % MODULO;
            if (sum % 2 == 0) {
                even++;
            } else {
                odd++;
            }
        }
        return subarrays;
    }
};



/*
给定 N 个人的出生年份和死亡年份，第 i 个人的出生年份为 birth[i]，死亡年份为 death[i]，实现一个方法以计算生存人数最多的年份。

你可以假设所有人都出生于 1900 年至 2000 年（含 1900 和 2000 ）之间。如果一个人在某一年的任意时期处于生存状态，那么他应该被纳入那一年的统计中。例如，生于 1908 年、死于 1909 年的人应当被列入 1908 年和 1909 年的计数。

如果有多个年份生存人数相同且均为最大值，输出其中最小的年份。

*/

const int max_len = 101;
class Solution {
public:
  int maxAliveYear(vector<int>& birth, vector<int>& death) {
    int len = birth.size();
    vector<int> comes(max_len, 0);
    vector<int> goes(max_len, 0);
    for (int i = 0; i < len; i++) {
      comes[birth[i] - 1900]++;
      goes[death[i] - 1900]++;
    }
    for (int i = 1; i < max_len; i++) {
      comes[i] += comes[i - 1];
      goes[i] += goes[i - 1];
    }
    int max_cnt = comes[0], ans = 0;
    for (int i = 1; i < max_len; i++) {
      int p = comes[i] - goes[i - 1];
      if (p > max_cnt) {
        max_cnt = p;
        ans = i;
      }
    }
    return ans + 1900;
  }
};

/*
给定两个字符串, A 和 B。

A 的旋转操作就是将 A 最左边的字符移动到最右边。 例如, 若 A = 'abcde'，在移动一次之后结果就是'bcdea' 。如果在若干次旋转操作之后，A 能变成B，那么返回True。

解题思路
两个字符串的长度不同，肯定false
如果用暴力法，挨个遍历A字符，找到和B第一个字符相等的，比如 A:12345,B 34512 则A的遍历顺序为34512，既要绕到开头且时间复杂度也是O(n^2)
有更巧妙的解法，就是给A后面再拼一个A，比如 1234512345，再判断B是否是A的子串，因为1234512345枚举了所有旋转数。

*/

class Solution {
    public boolean rotateString(String A, String B) {
        if (A.length() != B.length()) return false;
        return (A + A).contains(B);
    }
}

/* 逆波兰表达式 */ 

class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        std::stack<int> val;
        for (auto s : tokens) {
            if (s == "+" || s == "-" || s == "*" || s == "/") {
                int second = val.top(); val.pop();
                int first  = val.top(); val.pop();
                if (s == "+") {val.push(first + second);}
                if (s == "-") {val.push(first - second);}
                if (s == "*") {val.push(first * second);}
                if (s == "/") {val.push(first / second);}
            } else {
                val.push(stoi(s));
            }
        }
        return val.top();
    }
};


/* 你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。

空节点则用一对空括号 "()" 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。

*/
class Solution {
public:
    
    void preAccess(TreeNode* t, string & str)
    {
        if(t == NULL) return;
        str += to_string(t->val);
        if(t->left || t->right)
        {
            str += "(";
            preAccess(t->left, str);
            str += ")";
        }
        if(t->right)
        {
            str += "(";
            preAccess(t->right, str);
            str += ")";
        }
    }
    
    string tree2str(TreeNode* t) {
        string res = "";
        preAccess(t, res);
        return res;
    }
};



/* 
给你一个数组 nums ，每次操作你可以选择 nums 中的任意一个元素并将它改成任意值。

请你返回三次操作后， nums 中最大值与最小值的差的最小值。


当给定的数组长度不超过 44 时，我们总可以让所有的数字相同，所以我们直接考虑长度超过 44 的数组。

我们注意到，每次修改必然是将最大值改小，或者将最小值改大，这样才能让最大值与最小值的差尽可能小。

这样我们只需要找到最大的四个数与最小的四个数即可。当我们删去最小的 k(0 \leq k \leq 3)k(0≤k≤3) 个数，还需要删去 3-k3−k 个最大值。枚举这四种情况即可。
*/

class Solution {
public:
    int minDifference(vector<int>& nums) {
        int n = nums.size();
        if (n <= 4) {
            return 0;
        }

        sort(nums.begin(), nums.end());
        int ret = 2e9;
        for (int i = 0; i < 4; i++) {
            ret = min(ret, nums[n - 4 + i] - nums[i]);
        }
        return ret;
    }
};


/*
给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0。
*/

class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m=text1.size(),n=text2.size();
        
        int dp[m+1][n+1];
        memset(dp,0,sizeof(dp));

        for (int i=1;i<=m;i++) {
            for (int j=1;j<=n;j++) {
                if (text1[i-1]==text2[j-1]) {
                    dp[i][j]=dp[i-1][j-1]+1;
                } else {
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[m][n];
    }
};


/*
给定一个正整数，返回它在 Excel 表中相对应的列名称。

例如，

    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB
    ...
*/

class Solution {
public:
    string convertToTitle(int n) {
        string ans = "";
        while (n > 0) {
            n -= 1;
            ans.push_back('A' + (n % 26));
            n /= 26;
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};


/*
给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效的 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效的 IP 地址。
*/

class Solution {
private:
    static constexpr int SEG_COUNT = 4;

private:
    vector<string> ans;
    vector<int> segments;

public:
    void dfs(const string& s, int segId, int segStart) {
        // 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案
        if (segId == SEG_COUNT) {
            if (segStart == s.size()) {
                string ipAddr;
                for (int i = 0; i < SEG_COUNT; ++i) {
                    ipAddr += to_string(segments[i]);
                    if (i != SEG_COUNT - 1) {
                        ipAddr += ".";
                    }
                }
                ans.push_back(move(ipAddr));
            }
            return;
        }

        // 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯
        if (segStart == s.size()) {
            return;
        }

        // 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0
        if (s[segStart] == '0') {
            segments[segId] = 0;
            dfs(s, segId + 1, segStart + 1);
        }

        // 一般情况，枚举每一种可能性并递归
        int addr = 0;
        for (int segEnd = segStart; segEnd < s.size(); ++segEnd) {
            addr = addr * 10 + (s[segEnd] - '0');
            if (addr > 0 && addr <= 0xFF) {
                segments[segId] = addr;
                dfs(s, segId + 1, segEnd + 1);
            } else {
                break;
            }
        }
    }

    vector<string> restoreIpAddresses(string s) {
        segments.resize(SEG_COUNT);
        dfs(s, 0, 0);
        return ans;
    }
};

/*
编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。

如果是有效的 IPv4 地址，返回 "IPv4" ；
如果是有效的 IPv6 地址，返回 "IPv6" ；
如果不是上述类型的 IP 地址，返回 "Neither" 。
IPv4 地址由十进制数和点来表示，每个地址包含 4 个十进制数，其范围为 0 - 255， 用(".")分割。比如，172.16.254.1；

同时，IPv4 地址内的数不会以 0 开头。比如，地址 172.16.254.01 是不合法的。

IPv6 地址由 8 组 16 进制的数字来表示，每组表示 16 比特。这些组数字通过 (":")分割。比如,  2001:0db8:85a3:0000:0000:8a2e:0370:7334 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以， 2001:db8:85a3:0:0:8A2E:0370:7334 也是一个有效的 IPv6 address地址 (即，忽略 0 开头，忽略大小写)。

然而，我们不能因为某个组的值为 0，而使用一个空的组，以至于出现 (::) 的情况。 比如， 2001:0db8:85a3::8A2E:0370:7334 是无效的 IPv6 地址。

同时，在 IPv6 地址中，多余的 0 也是不被允许的。比如， 02001:0db8:85a3:0000:0000:8a2e:0370:7334 是无效的。
*/

class Solution {
public:
    bool validIPv4(string IP) {
        if (IP.empty() || IP.back() == '.' || IP.front() == '.')
            return false;
        int digit = 0;
        int dot_ind = -1;
        int dot_num = 0;
        for (int i = 0; i < IP.size(); ++i) {
            if (IP[i] == '.') {
                if (i - dot_ind == 1)
                    return false;
                digit = 0;
                dot_ind = i;
                ++dot_num;
            } else if (IP[i] >= '0' && IP[i] <= '9') {
                if (i - dot_ind > 1 && digit == 0)
                    return false;
                digit = 10 * digit + IP[i] - '0';
                if (digit > 255)
                    return false;
            } else {
                return false;
            }
        }
        return dot_num == 3;
    }
    bool validHex(char c) {
        return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
    }
    bool validIPv6(string IP) {
        if (IP.empty() || IP.back() == ':' || IP.front() == ':')
            return false;
        string elem;
        int colon_ind = -1;
        int colon_num = 0;
        for (int i = 0; i < IP.size(); ++i) {
            if (IP[i] == ':') {
                if (elem.empty())
                    return false;
                elem.clear();
                colon_ind = i;
                ++colon_num;
            } else if (validHex(IP[i])) {
                elem += IP[i];
                if (elem.size() > 4)
                    return false;
            } else {
                return false;
            }
        }
        return colon_num == 7;
    }
    string validIPAddress(string IP) {
        if (validIPv4(IP))
            return "IPv4";
        if (validIPv6(IP))
            return "IPv6";
        return "Neither";
    }
};


unsigned int ipToNum(char* ip)
{
	char* p;
	int sections[4]={0};
	int i=0;

	p = strtok(ip,".");
	while( p )
	{
		sections[i] = atoi(p);
		p = strtok(NULL,".");
		cout << sections[i] << endl;
		i++;
	}

	unsigned int num =0;
	for( int j=3,i=0 ; j>=0 ; j--,i++ )
	{
		num += (sections[i] <<(8*j));
	}
	
	return num;
}

/*
二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。

返回转换后的单向链表的头节点。

注意：本题相对原题稍作改动

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binode-lcci
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
	// pre全局变量，保存中序遍历的前一个节点
    TreeNode* pre = nullptr;
    void convertBiNodeCore(TreeNode* root) {
        if (root == nullptr)
            return;
        if (root->left != nullptr)
            convertBiNodeCore(root->left);
		// 中序遍历递归，pre就是前一个遍历到的节点；
        if (pre == nullptr) {
            pre = root;
        } else {
            pre->right = root;
            pre = root;
            root->left = nullptr;
        }
        if (root->right != nullptr)
            convertBiNodeCore(root->right);
    }
    TreeNode* convertBiNode(TreeNode* root) {
        if (root == nullptr)
            return nullptr;
        TreeNode *head = root;
        while (head->left != nullptr)
            head = head->left;
        convertBiNodeCore(root);
        return head;
    }
};


/*
给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
示例 1：

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
示例 2：

输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。
示例 3：

输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/word-break
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        auto wordDictSet = unordered_set <string> ();
        for (auto word: wordDict) {
            wordDictSet.insert(word);
        }

        auto dp = vector <bool> (s.size() + 1);
        dp[0] = true;
        for (int i = 1; i <= s.size(); ++i) {
            for (int j = 0; j < i; ++j) {
                if (dp[j] && wordDictSet.find(s.substr(j, i - j)) != wordDictSet.end()) {
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[s.size()];
    }
};


/*
有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。

对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor ... xor arr[Ri]）作为本次查询的结果。

并返回一个包含给定查询 queries 所有结果的数组。

 

示例 1：

输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]
输出：[2,7,14,8] 
解释：
数组中元素的二进制表示形式是：
1 = 0001 
3 = 0011 
4 = 0100 
8 = 1000 
查询的 XOR 值为：
[0,1] = 1 xor 3 = 2 
[1,2] = 3 xor 4 = 7 
[0,3] = 1 xor 3 xor 4 xor 8 = 14 
[3,3] = 8

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/xor-queries-of-a-subarray
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

class Solution {
public:
    vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {
        int n = arr.size();
        vector<int> pre(n + 1);
        for (int i = 1; i <= n; ++i) {
            pre[i] = pre[i - 1] ^ arr[i - 1];
        }
        vector<int> ans;
        for (const auto& query: queries) {
            ans.push_back(pre[query[0]] ^ pre[query[1] + 1]);
        }
        return ans;
    }
};

/*
给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

 

示例：

输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/3sum-closest
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/


class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        int best = 1e7;

        // 根据差值的绝对值来更新答案
        auto update = [&](int cur) {
            if (abs(cur - target) < abs(best - target)) {
                best = cur;
            }
        };

        // 枚举 a
        for (int i = 0; i < n; ++i) {
            // 保证和上一次枚举的元素不相等
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            // 使用双指针枚举 b 和 c
            int j = i + 1, k = n - 1;
            while (j < k) {
                int sum = nums[i] + nums[j] + nums[k];
                // 如果和为 target 直接返回答案
                if (sum == target) {
                    return target;
                }
                update(sum);
                if (sum > target) {
                    // 如果和大于 target，移动 c 对应的指针
                    int k0 = k - 1;
                    // 移动到下一个不相等的元素
                    while (j < k0 && nums[k0] == nums[k]) {
                        --k0;
                    }
                    k = k0;
                } else {
                    // 如果和小于 target，移动 b 对应的指针
                    int j0 = j + 1;
                    // 移动到下一个不相等的元素
                    while (j0 < k && nums[j0] == nums[j]) {
                        ++j0;
                    }
                    j = j0;
                }
            }
        }
        return best;
    }
};

/*
你有两个字符串，即pattern和value。 pattern字符串由字母"a"和"b"组成，用于描述字符串中的模式。例如，字符串"catcatgocatgo"匹配模式"aabab"（其中"cat"是"a"，"go"是"b"），该字符串也匹配像"a"、"ab"和"b"这样的模式。但需注意"a"和"b"不能同时表示相同的字符串。编写一个方法判断value字符串是否匹配pattern字符串。

示例 1：

输入： pattern = "abba", value = "dogcatcatdog"
输出： true
示例 2：

输入： pattern = "abba", value = "dogcatcatfish"
输出： false
示例 3：

输入： pattern = "aaaa", value = "dogcatcatdog"
输出： false
示例 4：

输入： pattern = "abba", value = "dogdogdogdog"
输出： true
解释： "a"="dogdog",b=""，反之也符合规则

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/pattern-matching-lcci
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

class Solution {
public:
    bool patternMatching(string pattern, string value) {
        int count_a = 0, count_b = 0;
        for (char ch: pattern) {
            if (ch == 'a') {
                ++count_a;
            } else {
                ++count_b;
            }
        }
        if (count_a < count_b) {
            swap(count_a, count_b);
            for (char& ch: pattern) {
                ch = (ch == 'a' ? 'b' : 'a');
            }
        }
        if (value.empty()) {
            return count_b == 0;
        }
        if (pattern.empty()) {
            return false;
        }
        for (int len_a = 0; count_a * len_a <= value.size(); ++len_a) {
            int rest = value.size() - count_a * len_a;
            if ((count_b == 0 && rest == 0) || (count_b != 0 && rest % count_b == 0)) {
                int len_b = (count_b == 0 ? 0 : rest / count_b);
                int pos = 0;
                bool correct = true;
                string value_a, value_b;
                for (char ch: pattern) {
                    if (ch == 'a') {
                        string sub = value.substr(pos, len_a);
                        if (!value_a.size()) {
                            value_a = move(sub);
                        } else if (value_a != sub) {
                            correct = false;
                            break;
                        }
                        pos += len_a;
                    } else {
                        string sub = value.substr(pos, len_b);
                        if (!value_b.size()) {
                            value_b = move(sub);
                        } else if (value_b != sub) {
                            correct = false;
                            break;
                        }
                        pos += len_b;
                    }
                }
                if (correct && value_a != value_b) {
                    return true;
                }
            }
        }
        return false;
    }
};

/*
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
示例 1：

输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]

方法一：回溯
首先使用哈希表存储每个数字对应的所有可能的字母，然后进行回溯操作。

回溯过程中维护一个字符串，表示已有的字母排列（如果未遍历完电话号码的所有数字，则已有的字母排列是不完整的）。该字符串初始为空。每次取电话号码的一位数字，从哈希表中获得该数字对应的所有可能的字母，并将其中的一个字母插入到已有的字母排列后面，然后继续处理电话号码的后一位数字，直到处理完电话号码中的所有数字，即得到一个完整的字母排列。然后进行回退操作，遍历其余的字母排列。

回溯算法用于寻找所有的可行解，如果发现一个解不可行，则会舍弃不可行的解。在这道题中，由于每个数字对应的每个字母都可能进入字母组合，因此不存在不可行的解，直接穷举所有的解即可。

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode-solutio/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
*/
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        vector<string> combinations;
        if (digits.empty()) {
            return combinations;
        }
        unordered_map<char, string> phoneMap{
            {'2', "abc"},
            {'3', "def"},
            {'4', "ghi"},
            {'5', "jkl"},
            {'6', "mno"},
            {'7', "pqrs"},
            {'8', "tuv"},
            {'9', "wxyz"}
        };
        string combination;
        backtrack(combinations, phoneMap, digits, 0, combination);
        return combinations;
    }

    void backtrack(vector<string>& combinations, const unordered_map<char, string>& phoneMap, const string& digits, int index, string& combination) {
        if (index == digits.length()) {
            combinations.push_back(combination);
        } else {
            char digit = digits[index];
            const string& letters = phoneMap.at(digit);
            for (const char& letter: letters) {
                combination.push_back(letter);
                backtrack(combinations, phoneMap, digits, index + 1, combination);
                combination.pop_back();
            }
        }
    }
};


/*
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

 

示例 1：

输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]

方法二：回溯法
思路和算法

方法一还有改进的余地：我们可以只在序列仍然保持有效时才添加 '(' or ')'，而不是像 方法一 那样每次添加。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，

如果左括号数量不大于 nn，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/generate-parentheses/solution/gua-hao-sheng-cheng-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
*/

class Solution {
    void backtrack(vector<string>& ans, string& cur, int open, int close, int n) {
        if (cur.size() == n * 2) {
            ans.push_back(cur);
            return;
        }
        if (open < n) {
            cur.push_back('(');
            backtrack(ans, cur, open + 1, close, n);
            cur.pop_back();
        }
        if (close < open) {
            cur.push_back(')');
            backtrack(ans, cur, open, close + 1, n);
            cur.pop_back();
        }
    }
public:
    vector<string> generateParenthesis(int n) {
        vector<string> result;
        string current;
        backtrack(result, current, 0, 0, n);
        return result;
    }
};


/*
给定一个整数序列：a1, a2, ..., an，一个132模式的子序列 ai, aj, ak 被定义为：当 i < j < k 时，ai < ak < aj。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。

注意：n 的值小于15000。


方法一：栈
我们首先考虑 a[i] < a[j] 的部分。当我们固定了 j 时，我可以在 j 的左侧找出一个最小的数作为 a[i]，这是因为最终我们需要满足 a[i] < a[k] < a[j]，那么 a[i] 一定越小越好。因此我们可以对数组 a 维护前缀最小值，即 min[j] = min(a[1 .. j])，这样对于一个固定的 j，min[j] 即为最优的 a[i]。

随后我们再考虑 a[k]，其中 a[k] 需要满足 a[i] < a[k] < a[j]，即 min[j] < a[k] < a[j]。我们可以从数组 a 的末尾开始，从后向前寻找 a[k]。

我们可以用栈来存储所有的 a[k]。在栈中，所有候选的 a[k] 保持降序，即栈顶的元素最小，栈底的元素最大。即如果我们遇到一个新的 a[k]，那么我们会将栈顶的元素依次出栈，直到新的 a[k] 为栈中的最小元素。我们在从右向左遍历数组 a 时，假设我们当前位于 a[j]，首先我们判断是否有 nums[j] > min[j]，如果不成立，那么我们要跳过这个 a[j]，否则我们将栈顶的元素依次出栈，直到栈顶元素 stack[top] 满足 stack[top] > min[j]。在这之后，我们可以确定栈中的所有元素都大于 min[j]（即 num[i]），因此如果此时栈顶的元素和 j 可以满足 132 模式，那么我们就找到了一组合法的满足 132 模式的 i, j, k，否则我们继续寻找，此时需要把 a[j] 入栈。

如果在遍历结束后，我们仍然没有找到满足 132 模式的 i, j, k，那么我们需要返回 False。

*/

class Solution {
public:
    bool find132pattern(vector<int>& nums) {
        if (nums.size() < 3)
            return false;
        std::stack <int> stack;
        auto min = std::vector<int>(nums.size());
        min[0] = nums[0];
        for (int i = 1; i < nums.size(); i++)
            min[i] = (min[i - 1] < nums[i]) ? min[i - 1] : nums[i];
        for (int j = nums.size() - 1; j >= 0; j--) {
            if (nums[j] > min[j]) {
                while (!stack.empty() && stack.top() <= min[j])
                    stack.pop();
                if (!stack.empty() && stack.top() < nums[j])
                    return true;
                stack.push(nums[j]);
            }
        }
        return false;
    }
};


/*
给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。

示例：
输入：S = "a1b2"
输出：["a1b2", "a1B2", "A1b2", "A1B2"]

输入：S = "3z4"
输出：["3z4", "3Z4"]

输入：S = "12345"
输出：["12345"]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/letter-case-permutation
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

class Solution {
public:
    vector<string> letterCasePermutation(string S) {
        vector<string> result{S};
        for (int i = 0; i < S.size(); i++) {
            if (isupper(S[i])) {
                int size = result.size();
                for (int j = 0; j < size; j++) {
                    string temp = result[j];
                    temp[i] = tolower(temp[i]);
                    result.emplace_back(move(temp));
                }
            } else if (islower(S[i])) {
                int size = result.size();
                for (int j = 0; j < size; j++) {
                    string temp = result[j];
                    temp[i] = toupper(temp[i]);
                    result.emplace_back(move(temp));
                }
            }
        }
        return result;
    }
};

/*
给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/trim-a-binary-search-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (!root) return root;
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);
        if (low <= root->val && root->val <= high) return root;
        return root->val < low ? root->right : root->left;
    }
};


/*
给你一个字符串 s ，请你拆分该字符串，并返回拆分后唯一子字符串的最大数目。

字符串 s 拆分后可以得到若干 非空子字符串 ，这些子字符串连接后应当能够还原为原字符串。但是拆分出来的每个子字符串都必须是 唯一的 。

注意：子字符串 是字符串中的一个连续字符序列。

方法一：回溯
拆分给定的字符串，要求拆分后的每个子字符串唯一，求子字符串的最大数目，可以通过回溯算法实现。

对于长度为 nn 的字符串，有 n-1n−1 个拆分点。从左到右遍历字符串，对于每个拆分点，如果在此拆分之后，新得到的一个非空子字符串（即拆分点左侧的最后一个被拆分出的非空子字符串）与之前拆分出的非空子字符串都不相同，则当前的拆分点可以进行拆分，然后继续对剩下的部分（即拆分点右侧的部分）进行拆分。

判断拆分出的非空子字符串是否有重复时，可以使用哈希表。

当整个字符串拆分完毕时，计算拆分得到的非空子字符串的数目，并更新最大数目。

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/split-a-string-into-the-max-number-of-unique-substrings/solution/chai-fen-zi-fu-chuan-shi-wei-yi-zi-zi-fu-chuan-de-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
*/
class Solution {
public:
    int maxSplit;

    void backtrack(int index, int split, string &s, unordered_set<string> &us) {
        int length = s.size();
        if (index >= length) {
            maxSplit = max(maxSplit, split);
        } else {
            for (int i = index; i < length; i++) {
                string substr = s.substr(index, i - index + 1);
                if (us.find(substr) == us.end()) {
                    us.insert(substr);
                    backtrack(i + 1, split + 1, s, us);
                    us.erase(substr);
                }
            }
        }
    }

    int maxUniqueSplit(string s) {
        maxSplit = 1;
        unordered_set<string> us;
        backtrack(0, 0, s, us);
        return maxSplit;
    }
};


/*
给定一个 没有重复 数字的序列，返回其所有可能的全排列。

示例:

输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/permutations
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

class Solution {
public:
    vector<vector<int>> res;
    vector<bool> uesd;
    void backtrack(vector<int>& nums, vector<int>& track)
    {
        //结束条件
        if(track.size() == nums.size())
        {
            res.push_back(track);
            return;
        }
        for(int i=0;i<nums.size();i++)
        {
            //排除非法选择
            if(uesd[i]) continue;//已经用过了
            //做选择
            track.push_back(nums[i]);
            uesd[i] = true;
            //进入下一层决策树
            backtrack(nums, track);
            //撤销选择
            track.pop_back();
            uesd[i] = false;
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<int> track;
        uesd.resize(nums.size());
        backtrack(nums, track);
        return res;
    }
};

/*
400. 第 N 位数字
在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...中找到第 n 位数字。

注意：n 是正数且在 32 位整数范围内（n < 231）。

示例 1：

输入：3
输出：3

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/nth-digit
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/


class Solution {
public:
    int findNthDigit(int n) {
        // 先找到digits
        long digits = 1;
        long base = 9;
        while (n - base * digits > 0)
        {
            n -= base * digits;
            base *= 10;
            ++digits;
        }

        // 找到目标的数字
        // 计算后n是对应的在当前digits下的序号
        // 例子1 位数是3， n=4 表示的是第四个， 对应的数字就是 100 + 3/3 = 101 里的 3%4=1的第一个数字
        // 例子2 位数是3，n=3 表示的是第三个，对应的数字是 100 + 3/3-1 = 100 里的 3%3+3=3的第三个数字
        // 考虑基数 10^(digits-1)
        int t = 1;
        for (int i = 1; i < digits; ++i)
        {
            t *= 10;
        }
        // 这里考虑一下对应的是第几个数字，需要考虑前面提到边缘情况就是正好能被digits整除
        int index = (n % digits == 0) ? digits : n % digits;
        t += index == digits ? n/digits - 1 : n/digits;

        // 按照位数去找对应的一位数字，这里是使用倒序的实现
        // 如果是最后一位，index=digits, 那么一次除法都没有
        // 如果是第一位，index=0, 则需要除digits-1次
        // 总结就是 digits - 位数
        for (int i = index; i < digits; ++i)
        {
            t /= 10;
        }
        // 取10的模得到对应的单个数字
        return t % 10;
    }
};

/* 笨阶乘 */
int clumsy(int N){
    int ans, i;
    int len = N / 4;
    if(N>=4){
        ans = N * (N - 1) / (N - 2) + (N - 3);
        for(i=1;i<len;i++){
            ans = ans - (N - 4 * i) * (N - 4 * i - 1) / (N - 4 * i - 2);
            ans = ans + (N - 4 * i - 3);
        }
        if((N - len * 4) == 3){
            ans = ans - 6;
        }
        else if((N - len * 4) == 2){
            ans = ans - 2;
        }
        else if((N - len * 4) == 1){
            ans = ans - 1;
        }        
    }
    else if(N == 3){
        ans = 6;
    }
    else if(N == 2){
        ans = 2;
    }
    else if(N == 1){
        ans = 1;
    }
    else if(N == 0){
        ans = 0;
    }
    return ans;
}

作者：PSsWBdoU99
链接：https://leetcode-cn.com/problems/clumsy-factorial/solution/ben-jie-cheng-yong-ben-fang-fa-wu-nao-pan-duan-yi-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

/*
二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/bianry-number-to-string-lcci
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

class Solution {
public:
    string printBin(double num) {
        string ans = "0.";
        while (num != 0) {
            num *= 2;
            if (num >= 1) {
                ans += "1";
                num -= 1;
            } else {
                ans += "0";
            }
            if (ans.size() > 32) return "ERROR";
        }
        return ans;
    }
};

/*
给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
示例 1：

输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"
示例 2：

输入："aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/palindromic-substrings
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

class Solution {
public:
    int countSubstrings(string s) {
        int n = s.size(), ans = 0;
        for (int i = 0; i < 2 * n - 1; ++i) {
            int l = i / 2, r = i / 2 + i % 2;
            while (l >= 0 && r < n && s[l] == s[r]) {
                --l;
                ++r;
                ++ans;
            }
        }
        return ans;
    }
};


/*
给你一个字符串 s 和一个整数数组 cost ，其中 cost[i] 是从 s 中删除字符 i 的代价。

返回使字符串任意相邻两个字母不相同的最小删除成本。

请注意，删除一个字符后，删除其他字符的成本不会改变。

示例 1：
输入：s = "abaac", cost = [1,2,3,4,5]
输出：3
解释：删除字母 "a" 的成本为 3，然后得到 "abac"（字符串中相邻两个字母不相同）。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/minimum-deletion-cost-to-avoid-repeating-letters
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

class Solution {
public:
    int minCost(string s, vector<int>& cost) {
        int n = s.size();
        int sum = 0;
        for(int i = 0;i<n-1;i++)
        {
            if(s[i] == s[i+1])
            {
                sum+= min(cost[i],cost[i+1]); 
                if(cost[i]>cost[i+1])swap(cost[i],cost[i+1]);
            }
        }
        return sum;
    }
};

/*
给你一个整数 n ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于  n 的 最简 分数 。分数可以以 任意 顺序返回。

 

示例 1：

输入：n = 2
输出：["1/2"]
解释："1/2" 是唯一一个分母小于等于 2 的最简分数。
示例 2：

输入：n = 3
输出：["1/2","1/3","2/3"]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/simplified-fractions
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/
class Solution {
public:
    vector<string> simplifiedFractions(int n) {
        vector<string> res;

        for (int b = 2; b <= n; ++b) {
            for (int a = 1; a < b; ++a) {
                if (gcd(a, b) == 1) {
                    res.push_back(to_string(a) + '/' + to_string(b));
                }
            }
        }

        return res;
    }
};


/*
搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/search-rotate-array-lcci
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        if (right == -1)
            return -1;
        while (left < right) {                                         // 循环结束条件left==right
            int mid = left + (right - left) / 2;
            if (nums[left] < nums[mid]) {                              // 如果左值小于中值，说明左边区间升序               
                if (nums[left] <= target && target <= nums[mid]) {     // 如果目标在左边的升序区间中，右边界移动到mid
                    right = mid;                                       
                } else {                                               // 否则目标在右半边，左边界移动到mid+1
                    left = mid + 1;                                    
                }
            } else if (nums[left] > nums[mid]) {                       // 如果左值大于中值，说明左边不是升序，右半边升序
                if (nums[left] <= target || target <= nums[mid]) {     // 如果目标在左边，右边界移动到mid
                    right = mid;                                       
                } else {                                               // 否则目标在右半边，左边界移动到mid+1
                    left = mid + 1;                                    
                }
            } else if (nums[left] == nums[mid]) {                      // 如果左值等于中值，可能是已经找到了目标，也可能是遇到了重复值
                if (nums[left] != target) {                            // 如果左值不等于目标，说明还没找到，需要逐一清理重复值。
                    left++;
                } else {                                               // 如果左值等于目标，说明已经找到最左边的目标值 
                    right = left;                                      // 将右边界移动到left，循环结束
                }
            }
        }
        return (nums[left] == target) ? left : -1;                     // 返回left，或者-1
    }
};

/*
给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。
一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。
请你返回乘积为正数的最长子数组长度。

示例  1：

输入：nums = [1,-2,-3,4]
输出：4
解释：数组本身乘积就是正数，值为 24 。
示例 2：

输入：nums = [0,1,-2,-3,-4]
输出：3
解释：最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。
注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

class Solution {
public:
    int getMaxLen(vector<int>& nums) {
        int length = nums.size();
        int positive = (nums[0] > 0);
        int negative = (nums[0] < 0);
        int maxLength = positive;
        for (int i = 1; i < length; ++i) {
            if (nums[i] > 0) {
                ++positive;
                negative = (negative > 0 ? negative + 1 : 0);
            }
            else if (nums[i] < 0) {
                int newPositive = negative > 0 ? negative + 1 : 0;
                int newNegative = positive + 1;
                tie(positive, negative) = {newPositive, newNegative};
            }
            else {
                positive = negative = 0;
            }
            maxLength = max(maxLength, positive);
        }
        return maxLength;
    }
};


/*
给你两个数 hour 和 minutes 。请你返回在时钟上，由给定时间的时针和分针组成的较小角的角度（60 单位制）。
*/
class Solution {
  public:
  double angleClock(int hour, int minutes) {
    int oneMinAngle = 6;
    int oneHourAngle = 30;

    double minutesAngle = oneMinAngle * minutes;
    double hourAngle = (hour % 12 + minutes / 60.0) * oneHourAngle;

    double diff = abs(hourAngle - minutesAngle);
    return min(diff, 360 - diff);
  }
};


/*
给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。

如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。

一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/linked-list-in-binary-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/
class Solution {
    bool dfs(TreeNode* rt, ListNode* head) {
        // 链表已经全部匹配完，匹配成功
        if (head == NULL) return true;
        // 二叉树访问到了空节点，匹配失败
        if (rt == NULL) return false;
        // 当前匹配的二叉树上节点的值与链表节点的值不相等，匹配失败
        if (rt->val != head->val) return false;
        return dfs(rt->left, head->next) || dfs(rt->right, head->next);
    }
public:
    bool isSubPath(ListNode* head, TreeNode* root) {
        if (root == NULL) return false;
        return dfs(root, head) || isSubPath(head, root->left) || isSubPath(head, root->right);
    }
};

/*
两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。

计算一个数组中，任意两个数之间汉明距离的总和。

方法一：考虑二进制中的每一位
汉明距离等于两个数二进制表示中对应位置不同的数量。假设数组中的每个数都表示为 k 位的二进制数（高位补 0），那么我们可以发现，要计算数组中任意两个数的汉明距离的总和，可以先算出数组中任意两个数二进制第 i 位的汉明距离的总和，在将所有的 k 位之和相加。也就是说，二进制中的每一位都是可以独立计算的。

因此，我们考虑数组中每个数二进制的第 i 位，假设一共有 t 个 0 和 n - t 个 1，那么显然在第 i 位的汉明距离的总和为 t * (n - t)。

由于所有的数都在 [0, 10^9] 的范围内，因此 k 最大为 31。我们只要计算出每一位上的汉明距离的总和，再相加即可。

作者：LeetCode
链接：https://leetcode-cn.com/problems/total-hamming-distance/solution/yi-ming-ju-chi-zong-he-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
*/
int totalHammingDistance(vector<int>& nums)
{
    if (nums.empty())
        return 0;

    int ans = 0, n = nums.size();
    vector<int> cnt(32, 0);         // count of elements with a particular bit ON

    for (auto num : nums) {         // loop over every element
        int i = 0;
        while (num > 0) {           // check every bit
            cnt[i] += (num & 0x1);
            num >>= 1;
            i++;
        }
    }

    for (auto&& k : cnt) {           // loop over every bit count
        ans += k * (n - k);
    }

    return ans;
}























